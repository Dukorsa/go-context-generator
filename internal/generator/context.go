package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"go-context-generator/internal/analyzer"
)

type Config struct {
	OutputDir      string
	SourceDir      string
	RemoveComments bool
	MinifyOutput   bool
}

type Generator struct {
	config           Config
	progressCallback func(current, total int)
}

type ProjectStats struct {
	TotalFiles    int
	TotalPackages int
	TotalImports  int
	TotalLOC      int
	LargestFile   string
	LargestSize   int64
}

func NewGenerator(config Config) *Generator {
	return &Generator{
		config: config,
	}
}

func (g *Generator) SetProgressCallback(callback func(current, total int)) {
	g.progressCallback = callback
}

func (g *Generator) GenerateContextFiles(files []*analyzer.GoFile) error {
	// Criar diretÃ³rio de saÃ­da
	if err := os.MkdirAll(g.config.OutputDir, 0755); err != nil {
		return fmt.Errorf("erro ao criar diretÃ³rio de saÃ­da: %w", err)
	}

	// Gerar arquivo de estrutura geral do projeto
	if err := g.generateProjectOverview(files); err != nil {
		return fmt.Errorf("erro ao gerar visÃ£o geral: %w", err)
	}

	// Gerar arquivos de contexto individuais
	total := len(files)
	for i, file := range files {
		if g.progressCallback != nil {
			g.progressCallback(i, total)
		}

		if err := g.generateContextFile(file, files); err != nil {
			return fmt.Errorf("erro ao gerar contexto para %s: %w", file.Name, err)
		}
	}

	if g.progressCallback != nil {
		g.progressCallback(total, total)
	}

	return nil
}

func (g *Generator) generateProjectOverview(files []*analyzer.GoFile) error {
	overviewFile := filepath.Join(g.config.OutputDir, "00_PROJECT_OVERVIEW.txt")

	var content strings.Builder

	// CabeÃ§alho principal
	content.WriteString("ðŸš€ GO PROJECT COMPLETE OVERVIEW\n")
	content.WriteString(strings.Repeat("=", 50) + "\n\n")
	content.WriteString(fmt.Sprintf("ðŸ“… Generated: %s\n", time.Now().Format("2006-01-02 15:04:05")))
	content.WriteString(fmt.Sprintf("ðŸ“ Source Directory: %s\n", g.config.SourceDir))
	content.WriteString(fmt.Sprintf("ðŸ“Š Total Files Analyzed: %d\n\n", len(files)))

	// EstatÃ­sticas do projeto
	stats := g.calculateProjectStats(files)
	content.WriteString("ðŸ“ˆ PROJECT STATISTICS\n")
	content.WriteString(strings.Repeat("-", 25) + "\n")
	content.WriteString(fmt.Sprintf("â€¢ Total Go Files: %d\n", stats.TotalFiles))
	content.WriteString(fmt.Sprintf("â€¢ Total Packages: %d\n", stats.TotalPackages))
	content.WriteString(fmt.Sprintf("â€¢ Total Imports: %d\n", stats.TotalImports))
	content.WriteString(fmt.Sprintf("â€¢ Total Lines of Code: %d\n", stats.TotalLOC))
	content.WriteString(fmt.Sprintf("â€¢ Largest File: %s (%d bytes)\n\n", stats.LargestFile, stats.LargestSize))

	// Estrutura de packages
	content.WriteString("ðŸ“¦ PACKAGE STRUCTURE\n")
	content.WriteString(strings.Repeat("-", 25) + "\n")
	g.writePackageStructure(&content, files)
	content.WriteString("\n")

	// Mapa completo de dependÃªncias
	content.WriteString("ðŸ”— DEPENDENCY MAP\n")
	content.WriteString(strings.Repeat("-", 20) + "\n")
	g.writeDependencyMap(&content, files)
	content.WriteString("\n")

	// Imports externos mais utilizados
	content.WriteString("ðŸ“¥ TOP EXTERNAL IMPORTS\n")
	content.WriteString(strings.Repeat("-", 30) + "\n")
	g.writeTopImports(&content, files)

	// RodapÃ©
	content.WriteString("\n" + strings.Repeat("â”€", 50) + "\n")
	content.WriteString("ðŸ¤– Optimized for AI Context Analysis\n")
	content.WriteString("âš¡ Generated by Go Context Generator Pro v2.0\n")

	return os.WriteFile(overviewFile, []byte(content.String()), 0644)
}

func (g *Generator) calculateProjectStats(files []*analyzer.GoFile) ProjectStats {
	stats := ProjectStats{
		TotalFiles: len(files),
	}

	packages := make(map[string]bool)
	imports := make(map[string]bool)

	for _, file := range files {
		packages[file.Package] = true
		stats.TotalLOC += file.LOC

		if file.Size > stats.LargestSize {
			stats.LargestSize = file.Size
			stats.LargestFile = file.Name
		}

		for _, imp := range file.Imports {
			imports[imp] = true
		}
	}

	stats.TotalPackages = len(packages)
	stats.TotalImports = len(imports)

	return stats
}

func (g *Generator) writePackageStructure(content *strings.Builder, files []*analyzer.GoFile) {
	packages := make(map[string][]*analyzer.GoFile)

	for _, file := range files {
		packages[file.Package] = append(packages[file.Package], file)
	}

	var pkgNames []string
	for pkg := range packages {
		pkgNames = append(pkgNames, pkg)
	}
	sort.Strings(pkgNames)

	for _, pkgName := range pkgNames {
		pkgFiles := packages[pkgName]
		content.WriteString(fmt.Sprintf("ðŸ“¦ %s (%d files)\n", pkgName, len(pkgFiles)))

		for _, file := range pkgFiles {
			relPath, _ := filepath.Rel(g.config.SourceDir, file.Path)
			content.WriteString(fmt.Sprintf("   â”œâ”€â”€ %s (%d LOC)\n", relPath, file.LOC))
		}
		content.WriteString("\n")
	}
}

func (g *Generator) writeDependencyMap(content *strings.Builder, files []*analyzer.GoFile) {
	for _, file := range files {
		if len(file.Dependencies) > 0 {
			relPath, _ := filepath.Rel(g.config.SourceDir, file.Path)
			content.WriteString(fmt.Sprintf("ðŸ“„ %s\n", relPath))

			for _, dep := range file.Dependencies {
				depRel, _ := filepath.Rel(g.config.SourceDir, dep)
				content.WriteString(fmt.Sprintf("   â””â”€â†’ %s\n", depRel))
			}
			content.WriteString("\n")
		}
	}
}

func (g *Generator) writeTopImports(content *strings.Builder, files []*analyzer.GoFile) {
	importCount := make(map[string]int)

	for _, file := range files {
		for _, imp := range file.Imports {
			// Filtrar apenas imports externos (nÃ£o locais do projeto)
			if !strings.Contains(imp, g.getProjectModule()) {
				importCount[imp]++
			}
		}
	}

	// Ordenar por frequÃªncia
	type importFreq struct {
		name  string
		count int
	}

	var imports []importFreq
	for imp, count := range importCount {
		imports = append(imports, importFreq{imp, count})
	}

	sort.Slice(imports, func(i, j int) bool {
		return imports[i].count > imports[j].count
	})

	// Mostrar top 10
	max := len(imports)
	if max > 10 {
		max = 10
	}

	for i := 0; i < max; i++ {
		imp := imports[i]
		content.WriteString(fmt.Sprintf("â€¢ %s (used %d times)\n", imp.name, imp.count))
	}
}

func (g *Generator) getProjectModule() string {
	modPath := filepath.Join(g.config.SourceDir, "go.mod")
	if content, err := os.ReadFile(modPath); err == nil {
		lines := strings.Split(string(content), "\n")
		for _, line := range lines {
			trimmed := strings.TrimSpace(line)
			if strings.HasPrefix(trimmed, "module ") {
				return strings.TrimSpace(strings.TrimPrefix(trimmed, "module "))
			}
		}
	}
	return filepath.Base(g.config.SourceDir)
}

func (g *Generator) generateContextFile(file *analyzer.GoFile, allFiles []*analyzer.GoFile) error {
	relPath, _ := filepath.Rel(g.config.SourceDir, file.Path)
	// Criar nome de arquivo mais limpo
	outputName := strings.ReplaceAll(relPath, string(filepath.Separator), "_")
	outputName = strings.ReplaceAll(outputName, ".go", "") + "_CONTEXT.txt"
	outputPath := filepath.Join(g.config.OutputDir, outputName)

	var content strings.Builder

	// CabeÃ§alho otimizado para IA
	content.WriteString("ðŸŽ¯ AI CONTEXT FILE\n")
	content.WriteString(strings.Repeat("=", 30) + "\n\n")

	// Metadados essenciais
	content.WriteString("ðŸ“‹ FILE METADATA\n")
	content.WriteString("----------------\n")
	content.WriteString(fmt.Sprintf("File: %s\n", relPath))
	content.WriteString(fmt.Sprintf("Package: %s\n", file.Package))
	content.WriteString(fmt.Sprintf("Lines of Code: %d\n", file.LOC))
	content.WriteString(fmt.Sprintf("Generated: %s\n\n", time.Now().Format("2006-01-02 15:04:05")))

	// Imports organizados
	if len(file.Imports) > 0 {
		content.WriteString("ðŸ“¥ DEPENDENCIES\n")
		content.WriteString("---------------\n")

		stdImports, extImports, localImports := g.categorizeImports(file.Imports)

		if len(stdImports) > 0 {
			content.WriteString("Standard Library:\n")
			for _, imp := range stdImports {
				content.WriteString(fmt.Sprintf("  â€¢ %s\n", imp))
			}
		}

		if len(extImports) > 0 {
			content.WriteString("External Packages:\n")
			for _, imp := range extImports {
				content.WriteString(fmt.Sprintf("  â€¢ %s\n", imp))
			}
		}

		if len(localImports) > 0 {
			content.WriteString("Local Project:\n")
			for _, imp := range localImports {
				content.WriteString(fmt.Sprintf("  â€¢ %s\n", imp))
			}
		}
		content.WriteString("\n")
	}

	// Estrutura simplificada do projeto
	content.WriteString("ðŸ—ï¸ PROJECT CONTEXT\n")
	content.WriteString("------------------\n")
	g.writeSimplifiedStructure(&content, allFiles)
	content.WriteString("\n")

	// CÃ³digo principal
	content.WriteString("ðŸ’» SOURCE CODE\n")
	content.WriteString(strings.Repeat("=", 15) + "\n\n")
	content.WriteString(file.CleanContent)
	content.WriteString("\n\n")

	// DependÃªncias locais (cÃ³digo relacionado)
	if len(file.Dependencies) > 0 {
		content.WriteString("ðŸ”— RELATED CODE\n")
		content.WriteString(strings.Repeat("=", 15) + "\n\n")

		fileMap := make(map[string]*analyzer.GoFile)
		for _, f := range allFiles {
			fileMap[f.Path] = f
		}

		for i, depPath := range file.Dependencies {
			if depFile, exists := fileMap[depPath]; exists {
				depRel, _ := filepath.Rel(g.config.SourceDir, depPath)

				content.WriteString(fmt.Sprintf("--- DEPENDENCY %d: %s ---\n", i+1, depRel))
				content.WriteString(fmt.Sprintf("Package: %s | LOC: %d\n\n", depFile.Package, depFile.LOC))
				content.WriteString(depFile.CleanContent)
				content.WriteString("\n\n")
			}
		}
	}

	// RodapÃ© otimizado
	content.WriteString(strings.Repeat("â”€", 40) + "\n")
	content.WriteString("ðŸ¤– AI-OPTIMIZED CONTEXT\n")
	content.WriteString("âš¡ Tokens minimized for efficient processing\n")

	return os.WriteFile(outputPath, []byte(content.String()), 0644)
}

func (g *Generator) categorizeImports(imports []string) ([]string, []string, []string) {
	var stdImports, extImports, localImports []string
	projectModule := g.getProjectModule()

	for _, imp := range imports {
		if strings.HasPrefix(imp, projectModule) {
			localImports = append(localImports, imp)
		} else if strings.Contains(imp, ".") {
			extImports = append(extImports, imp)
		} else {
			stdImports = append(stdImports, imp)
		}
	}

	sort.Strings(stdImports)
	sort.Strings(extImports)
	sort.Strings(localImports)

	return stdImports, extImports, localImports
}

func (g *Generator) writeSimplifiedStructure(content *strings.Builder, files []*analyzer.GoFile) {
	packages := make(map[string][]string)
	for _, file := range files {
		relPath, _ := filepath.Rel(g.config.SourceDir, file.Path)
		packages[file.Package] = append(packages[file.Package], filepath.Base(relPath))
	}

	var pkgNames []string
	for pkg := range packages {
		pkgNames = append(pkgNames, pkg)
	}
	sort.Strings(pkgNames)

	for _, pkg := range pkgNames {
		files := packages[pkg]
		if len(files) <= 3 {
			content.WriteString(fmt.Sprintf("%s: %s\n", pkg, strings.Join(files, ", ")))
		} else {
			content.WriteString(fmt.Sprintf("%s: %s... (+%d more)\n",
				pkg, strings.Join(files[:3], ", "), len(files)-3))
		}
	}
}
